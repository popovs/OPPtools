---
title: "`r paste('KBA:', params$report_title)`"
subtitle: "OPP KBA Report"
author: "Allison Patterson & Sarah Popov"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    toc: true
params:
  movebank_id: NA
  report_title: NA
  spp: NA
  breeding_pairs: NA
  minDist: NA
  maxDist: NA
  minDur: NA
  gapTime: NA
  gapDist: NA
  interpolateGaps: NA
  timestep: NA
  gridRes: NA
  gridExtend: NA
  speed: NA
  mapZoom: NA
  kernelSmoother: kernel_smoother
  iterations: interations
  levelUD: level_ud
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      dpi = 300,
                      fig.align = "center")

library(OPPtools)
library(dplyr)
library(track2KBA)

# Pull data and calculate necessary interim analysis steps
dat <- opp_download_data(study = params$movebank_id)
dat2 <- opp2KBA(dat)

# Get trips
trips <- opp_get_trips(dat2,
              innerBuff = params$minDist,
              returnBuff = params$maxDist,
              duration = params$minDur,
              gapTime = params$gapTime,
              gapDist = params$gapDist,
              gapLimit = params$gapLimit,
              showPlots = F
              )

# Interpolate trips
interp <- ctcrw_interpolation(trips,
                    site = dat2$site,
                    type = c('Complete', 'Incomplete', 'Gappy'),
                    timestep = params$timestep,
                    interpolateGaps = params$interpolateGaps,
                    showPlots = F)

# Get smoothers
h <- opp_href(interp$interp)
s <- opp_step(interp$interp)
s <- ifelse(s < 1, 1, s)

if (params$kernelSmoother == "href") {
  smooth = h
} else if (params$kernelSmoother == "href/2") {
  smooth = h/2
} else if (params$kernelSmoother == "step") {
  smooth = s
}

# Calc kernels
if (params$kernelSmoother != "bbmm") {
  kernels <- opp_kernel(interp,
                        interpolated = TRUE,
                        smoother = smooth,
                        extendGrid = params$gridExtend,
                        res = params$gridRes)
} else {
  kernels <- opp_bbmm(interp,
                      extendGrid = params$gridExtend,
                      res = params$gridRes)
}
```

\newpage

# Data summary 

Between `r min(year(dat$timestamp))` and `r max(year(dat$timestamp))`, `r length(unique(dat$individual_id))` individual `r params$spp`s at the `r unique(dat$study_site)` colony were tagged and tracked with `r as.character(unique(dat$sensor_type))` tags.

These `r length(unique(dat$individual_id))` individuals generated `r nrow(dat)` detections between `r as.Date(min(dat$timestamp))` and `r as.Date(max(dat$timestamp))`.

Data are stored on Movebank in project number `r as.character(params$movebank_id)`.

```{r trip map, fig.height=7, fig.cap = "Map of trips with raw GPS locations. Different colours represent trips from unique deployments. Location of the breeding colony is indicated with an orange point."}
opp_map_tracks(tracks = interp$data,
               center = dat2$site,
               zoom = params$mapZoom,
               coast_scale = 10,
               viridis_option = "D",
               show_locs = T)
```

# Key at-sea areas

The following at-sea areas were defined by following the OPP Workflow:

1. Define individual "trips"^[For further details on defining trips for these analyses, see the associated diagnostic file.]
2. Calculate a kernel density estimate using the `r params$kernelSmoother` kernel smoother
3. Estimate "key biological areas" of overlapping kernel areas using the `track2KBA` suite of tools

## Trips summary

```{r trip summary}
ft <- trips@data %>%
  filter(Type != 'Non-trip') %>%
  group_by(ID, tripID, Type) %>%
  mutate(
    duration = as.numeric(difftime(max(DateTime), min(DateTime), units = 'hours'))
  ) %>%
  group_by(Type) %>%
  summarize(
    `Number of trips` = length(unique(tripID)),
    `Number of locations` = n(),
    `Median duration (hrs)` = round(median(duration), 1),
    `Median trip distance (km)` = round(median(max(ColDist))/1000, 1)
    ) %>%
  flextable::flextable(cwidth =1.25) %>% 
  flextable::align(align = 'center', part = 'all') %>%
  flextable::set_caption("Summary of trip attributes by trip classification.")

ft
```

## Track representativeness

```{r repAssess}
repAssess <- track2KBA::repAssess(interp$interp,
                                 KDE = kernels,
                                 iteration = params$iterations,
                                 levelUD = params$levelUD)

# track2KBA::findSite
sites <- track2KBA::findSite(kernels,
                             represent = repAssess$out,
                             levelUD = params$levelUD,
                             popSize = params$breeding_pairs * 2,
                             polyOut = TRUE)
```

## Key biological areas

The `r params$kernelSmoother` smoother was chosen for kernel density estimation, with a value of `r if(params$kernelSmoother == "href"){ paste(h) } else if(params$kernelSmoother == "href/2") {paste(h/2)} else if(params$kernelSmoother == "step") {paste(s)} else {paste("Error: kernelSmoother not a valid value")}` km.

`r if(params$kernelSmoother == "step" & s == 1){"The step function resulted in a step smoother value of less than 1 km; therefore, 'step' kernel density estimates were calculated with a smoother value of 1 km."}`

```{r plot KBA}
opp_map_keyareas(track2KBA_UD = sites,
                 center = dat2$site,
                 zoom = params$mapZoom)
```
